DXRuby用ウィンドウシステムDXRubyWS リファレンスマニュアル

■１．はじめに

DXRubyWSはDXRuby用ゲームに組み込むことを想定したイベントドリブンのウィンドウシステムフレームワークです。ゲームのコードと独立した定義で、マウス操作などをトリガーにしたイベントに対処するコードを記述し、DXRubyWSシステムから呼び出されることで動作します。
この文書はDXRubyWSの基本部分のクラス・モジュールのリファレンスマニュアルとなります。標準GUIについては現在開発中でほとんど形になっていないのでマニュアルを書けるレベルではありません。興味がある人はサンプルプログラムやGUI部分のソースを眺めてみるとよいでしょう。標準GUIはどちらかというとアプリを作るための部品ではなく、このように書けばこのように動くというサンプル的な意味合いのほうが強いと思っています。

できること
・マウスの移動、ボタン操作、ホイール操作の各種イベント発行
・コンテナとコントロールによるオブジェクトツリー(Compositeパターンのようなもの)でのGUI構築
・シグナルハンドラの登録とシグナル発行による実行
・コンテナ上のコントロールのサイズ・配置を自動的に調整するオートレイアウト
・基本的なマウス操作でシグナルを発行してくれるサポートモジュール群

いずれ開発
・キーボード入力イベント

ずっと開発中
・GUI部品


■２．module WS

DXRubyWSはすべてWSモジュールの中に記述されています。が、トップレベルでincludeして使うことは想定していません。
基本部分は大きくわけて、WSモジュール、WSControlクラス、WSContainerクラス、WSDesktopクラス、WSLayoutクラス、サポートモジュール群に分かれています。
WSモジュールは各種クラス・モジュールの定義がほとんどですが、6つのモジュールメソッドが定義されています。最もよく使うのはWS.updateとWS.desktopです。

WS.update -> nil
 Window.loopの中にこの呼び出しを書くことでDXRubyWSのすべてが動作します。

WS.desktop -> WSDesktop
 スクリーン全体の最背面を表すWSDesktopオブジェクトを返します。スクリーン上にウィンドウなどを配置するときにはこのオブジェクトに対してコントロールの追加を行います。

WS.capture(obj) -> obj
 マウスキャプチャします。通常マウスイベントはマウスカーソルの位置にあるオブジェクトに対して送信されますが、このメソッドを呼び出して登録するとそれ以降のイベントは登録されたオブジェクトに対して送信されます。nilを指定すると解除します。

WS.captured?(obj) -> true/false
 引数で渡されたオブジェクトがマウスキャプチャされている場合にtrueを返します。

WS.default_z -> z (default 10000)
WS.default_z=(z) -> z
 WS.desktopで返されるWSDesktopオブジェクトは、何も描画しません。WS.desktopに対して追加したコントロールはスクリーン(DXRubyでいうWindow)に直接描画されます。Sprite#target=nil(or Window)とした状態です。DXRubyWS外で描画された画像との描画優先順位が不明になってしまうので、このメソッドでz値のデフォルトを設定します。初期値は10000となっています。たいがいの場合にはDXRubyWSで描画された画像が一番手前にくるでしょう。


■３．class WSControl < Sprite

すべてのコントロールのベースクラスです。DXRubyのSpriteを継承しています。生成したコントロールはWS.desktopかWSContainerオブジェクトのいずれかに登録する必要があります。WSContainerオブジェクトもWSControlを継承しているので、すべてのコントロールはWS.desktopを頂点としたオブジェクトツリーのどこかに位置します。このツリー内に存在しないコントロールにはマウスイベントは送信されませんし、描画もされません。
WSControlはSpriteを継承していますが、imageにはデフォルトでは何も設定されません。画面に描画する画像については自分でImageオブジェクトを生成して設定するなどしてください。

WSControl.new(x, y, width, height) -> WSControl
 座標x/yとコントロールのサイズwidth/heightを渡し、WSControlオブジェクトを生成します。座標は登録するWS.desktopもしくはWSContainerオブジェクトの左上を(0,0)とした相対位置で表します。
 引数に渡すwidth/heightはインスタンス変数@width/@heightに設定され、WSControl#width/heightで参照できます。Sprite#collisionにも設定されますので、Sprite#imageの画像サイズとは関係なくこの値でマウスの判定がされます。画像サイズで判定したい場合はcollision=nilとしてください。
 WSControlを継承してクラスを作った場合にはinitialize内でのsuperは一番最初に呼ぶことをオススメします。

WSControl#on_mouse_push(x, y) -> self       # 左ボタン押した
WSControl#on_mouse_release(x, y) -> self    # 左ボタン離した
WSControl#on_mouse_m_push(x, y) -> self     # 中ボタン押した
WSControl#on_mouse_m_release(x, y) -> self  # 中ボタン離した
WSControl#on_mouse_r_push(x, y) -> self     # 右ボタン押した
WSControl#on_mouse_r_release(x, y) -> self  # 右ボタン離した
WSControl#on_mouse_move(x, y) -> self       # カーソル動かした
WSControl#on_mouse_over -> self             # オブジェクトにカーソルが乗った
WSControl#on_mouse_out -> self              # オブジェクトからカーソルが離れた
WSControl#on_mouse_wheel_up(x, y) -> self   # ホイールを上に回した
WSControl#on_mouse_wheel_down(x, y) -> self # ホイールを下に回した
 それぞれ、マウスイベント発生時にDXRubyWSシステムから呼び出されるメソッドです。WSControlを継承してクラスを作った場合には、これらをオーバーライドして処理を書きます。superは最後に呼びます。最後に呼べない場合はselfを返すようにしてください。
 これらのメソッドはそれぞれon_を省いた名称のシグナルを発行します。

WSControl#mouse_event_dispach(event, x, y) -> イベントを受け取ったオブジェクト
 内部処理に使われるイベント伝播用メソッドです。上記マウスイベントを呼び出します。

WSControl#add_handler(signal, obj=nil, &block) -> nil
 シグナルハンドラを追加します。signalにはシグナル名を表すSymbolオブジェクトを渡します。このオブジェクトで指定したシグナルが発生したときに、objで指定されたMethodオブジェクトもしくはブロックが呼び出されます。両方指定した場合は両方呼び出されます。同じシグナルに複数のハンドラを登録することができます。
 MethodオブジェクトもProcオブジェクトも結局はcallメソッドが呼び出されるので、callメソッドが存在するオブジェクトをobjに指定するとそれが呼び出されます。

WSControl#signal(s, *args) -> nil
 sはシグナル名を表すSymbolオブジェクトを渡し、そのシグナルを発行します。シグナルハンドラに登録されているすべてのオブジェクトのcallメソッドを呼び出します。
 引数の数は自由ですが、シグナルハンドラに渡される引数にはシグナル発生元として第1引数にselfが追加されます。

WSControl#get_global_vertex -> [x, y]
 コントロールのスクリーン上での座標を返します。

WSControl#move(x, y) -> nil
 selfのx/yを変更します。変更後に:moveシグナルを引数x,yで発行します。

WSControl#resize(width, height) -> nil
 @width/@heightを変更します。Sprite#collisionも同時に変更します。変更後に:resizeシグナルを発行します。シグナルの引数にサイズは渡されませんが、objのwidth/heightが変更された後なのでシグナルハンドラではそれを利用できます。

プロパティ類
attr_accessor :parent, :font, :width, :height, :resizable_width, :resizable_height
attr_accessor :min_width, :min_height
 parentは登録された親のオブジェクト(WS.desktopもしくはWSContainerオブジェクト)が格納されます。
 fontは何もしなければFont.new(16)で作られたデフォルトフォントが設定されます。
 width/heightはnewで渡された値が設定されます。resizeで更新されます。
 resizable_width/heightはオートレイアウト機能で自動更新するかどうかが格納されます。デフォルトはfalseです。
 min_width/heightはオートレイアウト機能で縮小される最低サイズを設定します。デフォルトは16です。


■４．class WSContainer < WSControl

複数のコントロールを配下に持つことができるコンテナのクラスです。WSControlを継承しています。WSContainerはimageにRenderTargetオブジェクトを生成して保持し、配下のコントロールはそのRenderTargetオブジェクトがSprite#target=で自動的に設定されます。なので、配下のコントロールは基本的に親のオブジェクトの外側には描画できません。

WSContainer.new(x, y, width, height) -> WSContainer
 imageにRenderTarget.new(width, height)としてRenderTargetオブジェクトが設定されます。

WSContainer#add_control(obj, name=nil) -> obj
 selfの配下にobjを追加します。nameにSymbolオブジェクトを指定するとselfの特異メソッドとしてobjを返すメソッドnameを追加します。

WSContainer#remove_control(obj, name=nil) -> obj
 selfの配下のobjを削除します。nameにSymbolオブジェクトを指定するとその名前の特異メソッドも削除します。

WSContainer#update
 配下のオブジェクトのupdateを呼び出してから、自身のupdateを呼びます。

WSContainer#draw
 配下のオブジェクトのdrawを呼び出してから、自身のdrawを呼びます。

WSContainer#find_hit_object(x, y) -> WSControl
 内部処理に使われます。配下のオブジェクトのうち、(x, y)にヒットするオブジェクトを返します。

WSContainer#mouse_event_dispach(event, x, y) -> イベントを受け取ったオブジェクト
 内部処理に使われるイベント伝播用メソッドです。配下のオブジェクトのうち、find_hit_objectメソッドが返したオブジェクトに対してeventを転送します。

WSContainer#layout(type=nil, &block)
 オートレイアウト指定メソッドです。typeには:hbox、:vboxのいずれかを指定します。それぞれ横並び、縦並びを表します。
 blockにはオートレイアウトの指定コードを渡します。このブロックは生成したWSLayoutオブジェクトをselfとして呼ばれます。詳細はWSLayoutクラスを参照してください。

WSContainer#resize(width, height)
 selfのimageに格納されているRenderTargetオブジェクトをリサイズし、:resizeシグナルを発行してからオートレイアウトを実行します。

プロパティ類
attr_accessor :childlen
 配下のオブジェクトが格納されている配列です。格納順に描画しますが、マウスの判定は逆順になります。


■５．class WSDesktop < WSContainer

スクリーン全体を表すデスクトップオブジェクトです。マウスイベントの発生元です。require 'dxrubyws'した時点で生成されます。WS.desktopで参照できます。ユーザがnewすることは想定していません。
特別なメソッドを定義しているわけではありませんが、このオブジェクトにadd_controlしたもののみがマウスイベントを受け取り、描画もされます。
WS.updateの中身はWS.desktopに対するupdateとdrawの呼び出しです。


■６．class WSLayout

オートレイアウト機能です。WSContainer配下のコントロールの位置/サイズを自動的に調整します。WSContainer#layoutによりインスタンスが生成され、そのWSLayoutインスタンスのinstance_evalでブロックが実行されます。したがって、layoutメソッドに渡すブロックの中ではWSLayoutクラスのインスタンスメソッドを呼ぶことができます。

WSLayout.new(type=nil, obj, &b) -> WSLayout
 通常これを直接呼ぶことはありません。WSContainer#layoutもしくはWSLayout#layoutから呼ばれます。

WSLayout#add(obj, resizable_width=nil, resizable_height=nil)
 通常はlayoutメソッドに渡すブロックの中で呼び、objがレイアウトに登録されます。登録されたコントロールはlayoutメソッドで指定されたtypeにしたがって縦か横に並びます。
 resizable_width/heightはコントロールがリサイズ可能かどうかを指定します。リサイズ可能な場合、オートレイアウトによりサイズを変更されます。最小サイズはWSControlのmin_width/heightで指定できます。

WSLayout#layout(type=nil)
 typeには:hboxもしくは:vboxを指定します。それぞれaddされたコントロールが横(左から右)か縦(上から下)に並びます。
 以下:hboxの説明ですが、:vboxの場合は縦横が入れ替わるだけであとは同じです。

 横方向にリサイズ可能なコントロールが0個の場合、すべてのコントロールは元のサイズのまま均等間隔で横に並びます。
 横方向にリサイズ可能なコントロールが1個の場合、カツカツに詰めてリサイズ可能なコントロールを最大サイズにします。
 横方向にリサイズ可能なコントロールが2個以上の場合、リサイズ可能なコントロールをすべて同じサイズにしていっぱいに詰めます。
 縦方向にリサイズ可能なコントロールは縦方向に最大サイズになります。リサイズ不可能なものは真ん中に位置調整されます。

 typeを省略した場合、登録したコントロールのリサイズ/位置調整はされません。typeを省略して中身も空っぽなlayoutメソッドはスペース調整用コントロールとして機能します。
 例：
 layout(:hbox) do
   add button1
   layout
   add button2
 end
 とすると、button1は左端、button2は右端に配置されます。

プロパティ類
attr_accessor :type, :x, :y, :width, :height, :resizable_width, :resizable_height, :obj
attr_accessor :margin_left, :margin_right, :margin_top, :margin_bottom
attr_accessor :min_width, :min_height

type/x/y/width/height/resizable_width/resizable_height/min_width/min_heightは上記で説明したとおりです。これらの設定はWSLayoutオブジェクトにも存在し機能しますので、self.xx=という形でブロック内に記述するとそのように設定されます。
objは内部処理用で、上位のWSLayoutオブジェクトが格納されます。
margin_left/right/top/bottomはレイアウトのそれぞれ左右上下のマージンで、ピクセルで表現します。指定したスペースが確保されます。


■７．サポートモジュール

マウスイベントを受け取り、なんらかの判定を行ってシグナルを発行するモジュール群です。ものによってシグナルを発行する以外のこともします。
WSControl/WSContainerを継承したクラスにincludeするか、生成したオブジェクトにextendして使います。
疲れてきたので詳細はソースおよびコメントを見てください。module.rbです。


■８．おしまい

この文書はリファレンスマニュアルですので、具体的な利用方法などは挙げておらず、これを見ただけではよくわからないという感想になるんじゃないかと思います。標準GUIがサンプルになりますので参考にどうぞ。
今後、アーキテクチャマニュアルやチュートリアルを書いていこうと考えております。
いつになるかわかりませんがお待ちください。
